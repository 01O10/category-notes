[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "category",
    "section": "",
    "text": "Preface\nThere are notes on Category Theory."
  },
  {
    "objectID": "intro.html#the-low-level-perspective",
    "href": "intro.html#the-low-level-perspective",
    "title": "1  Understanding Category Theory, Type Theory, and Logic",
    "section": "1.1 The Low-Level Perspective",
    "text": "1.1 The Low-Level Perspective\nAt the lowest level of computing, everything is just bytes—binary sequences of 0s and 1s. These bytes represent data—whether numbers, text, images, or sound—everything you interact with on your computer is ultimately made up of bytes.\nFor example, consider the byte 01001000. In binary encoding, this byte represents the character 'H' in the ASCII character set. Similarly, 01100101 represents 'e', and 01101100 represents 'l'. A sequence of these bytes might represent an entire message, such as the word “Hello”.\nBytes are the raw material of computing, but they don’t mean much on their own unless we impose some structure. That’s where types come in. Type theory provides a way to give structure to these raw bytes. In a type system, we classify data into categories or types. This makes it easier to reason about and manipulate the data. For instance, we could classify 01001000 as a character or 01100101 as an integer, depending on the context."
  },
  {
    "objectID": "intro.html#type-theory-in-mathematics",
    "href": "intro.html#type-theory-in-mathematics",
    "title": "1  Understanding Category Theory, Type Theory, and Logic",
    "section": "1.2 Type Theory in Mathematics",
    "text": "1.2 Type Theory in Mathematics\nAlthough type theory was originally developed to improve computing, its roots lie in mathematics. The history of type theory can be traced back to logical paradoxes in set theory. Let’s explore one of the most famous of these paradoxes: Russell’s Paradox.\n\n1.2.1 Russell’s Paradox: A Deeper Look\nIn 1901, Bertrand Russell discovered a paradox in set theory, which is the branch of mathematics that deals with collections of objects. The paradox arises when you try to define the set of all sets that do not contain themselves.\nLet’s break it down:\n\nConsider the set ( R ), defined as: “the set of all sets that do not contain themselves.”\n\nNow, ask yourself: Does the set ( R ) contain itself?\n\nIf ( R ) contains itself, then by its definition, it must not contain itself, because it only contains sets that do not contain themselves.\nIf ( R ) does not contain itself, then by its definition, it must contain itself because it is a set that does not contain itself.\n\nThis creates a contradiction.\nTo solve this, Russell proposed introducing a type system to prevent sets from containing themselves. In this system, we can categorize sets into levels or types, so that a set cannot be a member of itself, thus avoiding the paradox.\n\n\n\n1.2.2 The Solution via Type Theory\nRussell’s type system was the precursor to type theory as we know it today. He proposed a hierarchy of sets—called types—to organize sets and avoid paradoxes like the one above.\n\n1.2.2.1 Example: Types in Set Theory\n\nType 0: Sets that do not contain themselves.\nType 1: Sets that contain only sets from Type 0.\nType 2: Sets that contain only sets from Type 1, and so on.\n\nWith this hierarchical structure, a set of Type 0 cannot contain itself because it can only contain sets from Type 1, which are on a higher level. By categorizing sets in this way, Russell’s system ensured that paradoxes like the one mentioned above would not occur.\nThis idea of types would go on to influence the development of Martin-Löf Type Theory (MLTT), a more sophisticated type system that is widely used in both mathematics and computer science."
  },
  {
    "objectID": "intro.html#martin-löf-type-theory-mltt",
    "href": "intro.html#martin-löf-type-theory-mltt",
    "title": "1  Understanding Category Theory, Type Theory, and Logic",
    "section": "1.3 Martin-Löf Type Theory (MLTT)",
    "text": "1.3 Martin-Löf Type Theory (MLTT)\n\n1.3.1 Key Ideas in MLTT\n\n1.3.1.1 Types as Sets\nIn MLTT, types are collections of objects, similar to sets in set theory. For example, the type Nat (natural numbers) contains objects like 0, 1, 2, etc.\n\n1.3.1.1.1 Example:\nLet’s define the type Nat: - Nat = {0, 1, 2, 3, ...}.\nThis means the elements of the type Nat are natural numbers.\n\n\n\n1.3.1.2 Types as Propositions\nIn MLTT, types can also represent logical propositions. A type A → B represents the proposition “if A is true, then B is true.”\n\n1.3.1.2.1 Example:\nLet A be the type of natural numbers greater than 0, and B be the type of even numbers: - A = {1, 2, 3, 4, ...}. - B = {2, 4, 6, 8, ...}.\nThe type A → B means “if a number is greater than 0, then it is an even number.”\n\n\n\n1.3.1.3 Proofs as Objects\nIn MLTT, a proof of a proposition is itself a term of a specific type. So, a proof of A → B is a function that takes an element of type A and returns an element of type B.\n\n1.3.1.3.1 Example:\nLet’s define a function f: A → B that proves “if a number is greater than 0, then it is even.” We could define f as follows: - f(1) = 2, f(2) = 4, f(3) = 6, etc.\nHere, f is a function that constructs even numbers, proving the implication A → B.\n\n\n\n1.3.1.4 Constructive Proofs\nMLTT insists on constructive proofs. This means if we prove the existence of an object, we must provide a concrete example.\n\n1.3.1.4.1 Example:\nTo prove “there exists an even number greater than 0,” we must construct such a number: - f: Nat where f could return 2, which is the smallest even number greater than 0.\n\n\n\n\n1.3.2 Example in MLTT (Proving Implication)\nLet’s prove the implication A → B, where A and B are types (propositions).\n\n1.3.2.1 Steps:\n\nAssume a function f: A → B exists.\nThis means that for every element of type A, the function f produces an element of type B.\nProve A → B\nTo prove the implication, we must show that for any element a of type A, we can derive an element b of type B.\nUse f to transform elements of A into elements of B.\nSince f is of type A → B, it provides us with a proof. For example, if a is an element of type A, applying f(a) gives us an element of type B.\n\n\n\n1.3.2.2 Example:\n\nLet A be the type of natural numbers greater than 0.\nLet B be the type of even numbers.\nWe assume f: A → B such that f(a) returns an even number for every a &gt; 0.\n\nThe function f can be a function that returns the next even number greater than a."
  },
  {
    "objectID": "intro.html#the-curry-howard-lambek-isomorphism",
    "href": "intro.html#the-curry-howard-lambek-isomorphism",
    "title": "1  Understanding Category Theory, Type Theory, and Logic",
    "section": "1.4 The Curry-Howard-Lambek Isomorphism",
    "text": "1.4 The Curry-Howard-Lambek Isomorphism\n\n1.4.1 The Correspondence\n\n1.4.1.1 Logic ↔︎ Type Theory\n\nIn logic, a proof is a sequence of steps that proves a statement.\nIn type theory, a type represents a proposition, and a term (a function) is a proof of that type.\n\n\n1.4.1.1.1 Example:\n\nLogical statement: (A → B) means “if A is true, then B is true.”\nType theory: (A → B) is a type, and a function that takes an element of type A and returns an element of type B is a proof of that type.\n\n\n\n\n1.4.1.2 Type Theory ↔︎ Category Theory\n\nIn category theory, objects are types, and morphisms (arrows) are functions between types.\nIn type theory, a term (proof) is a morphism that transforms one object (type) into another.\n\n\n1.4.1.2.1 Example:\n\nIn category theory, a morphism from object A to object B represents a function from type A to type B.\n\n\n\n\n\n1.4.2 Step-by-Step Example of the Curry-Howard-Lambek Isomorphism\nLet’s walk through how a logical statement, a type in type theory, and a morphism in category theory are related.\n\n1.4.2.1 Logical Statement:\n\nConsider the logical statement (A → B), which means “if A is true, then B is true.”\n\n\n\n1.4.2.2 In Type Theory:\n\nThe logical statement A → B corresponds to the type A → B in type theory.\nA function of type A → B is a proof of this implication. It takes an element of type A and returns an element of type B.\n\n\n\n1.4.2.3 In Category Theory:\n\nIn category theory, the objects are types (A, B).\nThe morphisms (arrows) between objects represent functions. So, a morphism from object A to object B represents a function that transforms elements of type A into elements of type B.\n\nThus, the Curry-Howard-Lambek Isomorphism tells us that: - The logical statement (A → B) is represented by a type A → B. - A proof of this logical statement corresponds to a term (function) of type A → B. - In category theory, this is captured as a morphism from object A to object B.\n\n\n1.4.2.4 Concrete Example:\n\nLet A = {1, 2, 3, ...} and B = {2, 4, 6, 8, ...}.\nA function f: A → B that proves “if a number is natural, then it is even” could map each element a from A to the next even number b in B:\n\nf(1) = 2, f(2) = 4, f(3) = 6, ....\n\n\nIn category theory, the function f is a morphism between objects A and B. In type theory, f is a term of type A → B. In logic, f is a proof of the statement “if A, then B.”"
  },
  {
    "objectID": "intro.html#the-nature-of-mathematics-discovery-or-invention",
    "href": "intro.html#the-nature-of-mathematics-discovery-or-invention",
    "title": "1  Understanding Category Theory, Type Theory, and Logic",
    "section": "1.5 The Nature of Mathematics: Discovery or Invention?",
    "text": "1.5 The Nature of Mathematics: Discovery or Invention?\nMathematicians often debate whether mathematics is an invention of the human mind or a discovery of universal truths. Unlike physicists, who conduct experiments to uncover the natural laws of the universe, mathematicians engage in abstract reasoning and logical deduction. Despite this, different branches of mathematics often uncover equivalent structures, suggesting that there may be some underlying objective reality to these concepts."
  },
  {
    "objectID": "intro.html#the-limits-of-human-cognition",
    "href": "intro.html#the-limits-of-human-cognition",
    "title": "1  Understanding Category Theory, Type Theory, and Logic",
    "section": "1.6 The Limits of Human Cognition",
    "text": "1.6 The Limits of Human Cognition\nHumans evolved primarily for survival—identifying threats, securing food, and navigating social relationships. Our brains are excellent at dealing with concrete, immediate problems, but abstract reasoning is a more recent development. To handle complexity, we often use decomposition—breaking complex problems into simpler, manageable parts.\nThis principle, found in everything from science to programming, is central to how we understand and solve problems."
  },
  {
    "objectID": "intro.html#is-the-universe-fundamentally-composable",
    "href": "intro.html#is-the-universe-fundamentally-composable",
    "title": "1  Understanding Category Theory, Type Theory, and Logic",
    "section": "1.7 Is the Universe Fundamentally Composable?",
    "text": "1.7 Is the Universe Fundamentally Composable?\nIn physics, scientists have long adhered to a reductionist approach—breaking matter down into smaller and smaller components. For instance, atoms are composed of protons, neutrons, and electrons, which are themselves composed of quarks. However, recent developments in physics challenge this reductionist view:\n\nQuantum mechanics shows that particles don’t behave like simple building blocks.\nString theory suggests that the fundamental particles are not points, but tiny vibrating strings.\n\nThese discoveries raise a profound question: is the universe inherently composable, or is this just a human cognitive strategy?"
  },
  {
    "objectID": "intro.html#category-theory-as-a-study-of-human-thought",
    "href": "intro.html#category-theory-as-a-study-of-human-thought",
    "title": "1  Understanding Category Theory, Type Theory, and Logic",
    "section": "1.8 Category Theory as a Study of Human Thought",
    "text": "1.8 Category Theory as a Study of Human Thought\nCategory theory, often seen as a highly abstract branch of mathematics, may not be as concerned with the intrinsic nature of the universe as we might think. Instead, it provides a framework for understanding how humans reason about complexity. It describes patterns and structures that our minds impose on the problems we encounter.\nIn this sense, category theory might be more about epistemology—how we understand the world—than ontology—what the world actually is."
  },
  {
    "objectID": "category_theory.html",
    "href": "category_theory.html",
    "title": "2  Associativity and its Role in Categories",
    "section": "",
    "text": "3 Associativity and its Role in Categories"
  },
  {
    "objectID": "category_theory.html#can-we-have-non-associative-theories",
    "href": "category_theory.html#can-we-have-non-associative-theories",
    "title": "2  Associativity and its Role in Categories",
    "section": "3.1 Can We Have Non-Associative Theories?",
    "text": "3.1 Can We Have Non-Associative Theories?\nAssociativity is a fundamental property in category theory. When composing morphisms (arrows) in a category, the order of grouping does not affect the result:\n\\[(f \\circ g) \\circ h = f \\circ (g \\circ h)\\]\nThis guarantees that composition is well-defined and predictable. But what happens if we weaken associativity? Can we still construct meaningful mathematical structures?\nThe answer is yes—many mathematical frameworks allow associativity to hold only up to isomorphism. This means that different ways of composing elements may not be strictly identical but can be transformed into each other in a controlled way.\n\n3.1.1 Example: Floating Point Arithmetic\nIn floating-point arithmetic, associativity does not hold due to rounding errors:\n(1.0 + 1e-10) + 1e-10 != 1.0 + (1e-10 + 1e-10)\nThis inconsistency prevents floating-point operations from forming a category because composition must be strictly associative.\n\n\n3.1.2 Example: Higher Structures in Mathematics\nIn more advanced mathematics, structures like monoidal categories allow composition to be associative only up to isomorphism. This flexibility is crucial in fields like algebraic topology and quantum mechanics."
  },
  {
    "objectID": "category_theory.html#categories-vs.-groups",
    "href": "category_theory.html#categories-vs.-groups",
    "title": "2  Associativity and its Role in Categories",
    "section": "3.2 Categories vs. Groups",
    "text": "3.2 Categories vs. Groups\nCategory theory generalizes structures like monoids and groups. A monoid consists of elements with an associative binary operation and an identity element. A group extends this by requiring that every element has an inverse.\n\n3.2.1 What Happens When Morphisms Have Inverses?\nIf every morphism in a category has an inverse, the category is called a groupoid. This generalizes the concept of a group by allowing multiple objects. Unlike a single group where all elements interact, a groupoid consists of a network of invertible transformations.\n\n\n3.2.2 Composition in Categories vs. Groups\n\nIn groups, every element has an inverse, ensuring symmetry.\nIn categories, morphisms may not be invertible, making them more flexible but less rigid than groups.\nComposition in categories is partial—morphisms can only compose if the target of one matches the source of another."
  },
  {
    "objectID": "category_theory.html#category-theory-in-programming",
    "href": "category_theory.html#category-theory-in-programming",
    "title": "2  Associativity and its Role in Categories",
    "section": "3.3 Category Theory in Programming",
    "text": "3.3 Category Theory in Programming\n\n3.3.1 The Category of Types\nFunctional programming languages like Haskell and ML provide concrete examples of category theory in action. In these languages:\n\nTypes correspond to objects in a category.\nFunctions correspond to morphisms between those objects.\n\nA function f: A → B represents an arrow from type A to type B. Function composition obeys associativity, making the set of types and functions a valid category.\n\n3.3.1.1 Special Case in Haskell: Laziness and Bottom Values\nHaskell introduces additional complexity because every type includes an undefined value (⊥), representing non-termination. This means that function composition in Haskell aligns more closely with enriched categories, where additional structure (like computational effects) must be considered.\n\n\n\n3.3.2 Types as Sets\nIn ML, types can be seen as sets of values, making function application resemble set functions in mathematics. This model works well because ML lacks non-terminating computations, unlike Haskell.\nThus, programming categories often model the category of sets:\n\nObjects = types (sets of values)\nMorphisms = functions between types"
  },
  {
    "objectID": "category_theory.html#constructing-a-category-from-sets",
    "href": "category_theory.html#constructing-a-category-from-sets",
    "title": "2  Associativity and its Role in Categories",
    "section": "3.4 Constructing a Category from Sets",
    "text": "3.4 Constructing a Category from Sets\n\n3.4.1 The Category of Sets (Set)\nIn category theory, we can construct a category from set theory:\n\nObjects: Sets\nMorphisms: Functions between sets\n\nA key feature is that once we define a category, we ignore the internal structure of sets. We only care about how objects interact via morphisms.\n\n\n3.4.2 Composition of Functions\nFunction composition provides a natural example of category composition:\nIf f: A → B and g: B → C, then their composition g ∘ f: A → C is defined as:\n\\[ (g ∘ f)(x) = g(f(x)) \\]\nThis satisfies associativity:\n\\[ (h ∘ g) ∘ f = h ∘ (g ∘ f) \\]\nwhere h: C → D is another function.\n\n\n3.4.3 Identity Morphisms\nEach set has an identity function:\n\\[ id_A: A → A \\]\nwhich satisfies:\n\\[ f ∘ id_A = f \\quad \\text{and} \\quad id_B ∘ f = f \\]\nfor any function f: A → B. These identity functions ensure that the category of sets (Set) meets the identity law of category theory."
  },
  {
    "objectID": "category_theory.html#the-power-of-abstraction-in-category-theory",
    "href": "category_theory.html#the-power-of-abstraction-in-category-theory",
    "title": "2  Associativity and its Role in Categories",
    "section": "3.5 The Power of Abstraction in Category Theory",
    "text": "3.5 The Power of Abstraction in Category Theory\n\n3.5.1 Forgetting Internal Structure\nCategory theory emphasizes relationships over internal structure. Once we construct a category, we disregard the nature of objects and focus on how they connect through morphisms.\n\nThis parallels data hiding in programming: objects expose interfaces (morphisms) rather than their internal workings.\nA category provides a high-level view where composition is central, making it a tool for reasoning about abstract mathematical structures.\n\n\n\n3.5.2 Why is This Useful?\n\nModularity: Systems can be understood in terms of how their parts interact.\nReusability: Abstract structures like functors and monads apply across different domains (e.g., databases, compiler design, quantum mechanics).\nUnification: Concepts from algebra, topology, and logic can be studied within a single framework."
  },
  {
    "objectID": "category_theory.html#conclusion",
    "href": "category_theory.html#conclusion",
    "title": "2  Associativity and its Role in Categories",
    "section": "3.6 Conclusion",
    "text": "3.6 Conclusion\nCategory theory provides a powerful lens for understanding mathematical and computational structures. By focusing on morphisms and their composition, it allows us to study how objects interact without needing to understand their internal construction. This abstraction leads to new insights in both mathematics and computer science, making category theory a fundamental tool for formal reasoning."
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "3  Relations and Functions",
    "section": "",
    "text": "4 Relations\nA function is:\nUnderstanding functions and relations helps in many fields, from mathematics to computer science. Knowing when a function is invertible, injective, or surjective allows us to determine how information is preserved, mapped, and structured.\nBy mastering these concepts, you can better analyze transformations, abstractions, and models in various domains."
  },
  {
    "objectID": "functions.html#what-is-a-relation",
    "href": "functions.html#what-is-a-relation",
    "title": "3  Relations and Functions",
    "section": "4.1 What is a Relation?",
    "text": "4.1 What is a Relation?\nA relation is a set of ordered pairs where elements from one set are associated with elements from another set.\nFor example, if we have two sets:\n\n\\(A = \\{1, 2, 3\\}\\)\n\\(B = \\{a, b, c\\}\\)\n\nA relation between them could be:\n\\[\nR = \\{(1, a), (2, b), (3, c)\\}\n\\]"
  },
  {
    "objectID": "functions.html#relations-and-cartesian-products",
    "href": "functions.html#relations-and-cartesian-products",
    "title": "3  Relations and Functions",
    "section": "4.2 Relations and Cartesian Products",
    "text": "4.2 Relations and Cartesian Products\nA relation can be understood through the Cartesian product of two sets. The Cartesian product \\(A \\times B\\) consists of all possible pairs:\n\\[\nA \\times B = \\{(1, a), (1, b), (1, c), (2, a), (2, b), (2, c), (3, a), (3, b), (3, c)\\}\n\\]\nA relation is simply a subset of this Cartesian product."
  },
  {
    "objectID": "functions.html#what-is-a-function",
    "href": "functions.html#what-is-a-function",
    "title": "3  Relations and Functions",
    "section": "5.1 What is a Function?",
    "text": "5.1 What is a Function?\nA function is a special type of relation that has a well-defined directionality: each input from the domain is mapped to exactly one output in the codomain."
  },
  {
    "objectID": "functions.html#key-properties-of-functions",
    "href": "functions.html#key-properties-of-functions",
    "title": "3  Relations and Functions",
    "section": "5.2 Key Properties of Functions",
    "text": "5.2 Key Properties of Functions\n\nA function must assign exactly one output to each input.\nThe domain is the set of all possible inputs.\nThe codomain is the set of possible outputs (though not necessarily all elements in the codomain are used).\nThe actual values a function maps to are called the image of the function.\n\nFor example, if we define a function \\(f: A \\to B\\) as:\n\\[\nf(x) = x^2, \\quad A = \\{1, 2, 3\\}, \\quad B = \\{1, 4, 9, 10\\}\n\\]\nThen:\n\\[\nf(1) = 1, \\quad f(2) = 4, \\quad f(3) = 9\n\\]"
  },
  {
    "objectID": "functions.html#total-functions-vs.-partial-functions",
    "href": "functions.html#total-functions-vs.-partial-functions",
    "title": "3  Relations and Functions",
    "section": "5.3 Total Functions vs. Partial Functions",
    "text": "5.3 Total Functions vs. Partial Functions\n\nA total function maps every element of the domain to an element in the codomain.\nA partial function may leave some elements of the domain unmapped."
  },
  {
    "objectID": "functions.html#when-is-a-function-invertible",
    "href": "functions.html#when-is-a-function-invertible",
    "title": "3  Relations and Functions",
    "section": "6.1 When is a Function Invertible?",
    "text": "6.1 When is a Function Invertible?\nA function is invertible if there exists another function that can reverse its effect. That is, given an output, we can determine the unique input that produced it.\nExample: If \\(f(x) = x + 2\\), the inverse function is \\(g(x) = x - 2\\), because applying \\(g\\) after \\(f\\) returns the original input:\n\\[\ng(f(x)) = (x + 2) - 2 = x\n\\]\nNot all functions are invertible! A function must be bijective (both injective and surjective) to have an inverse."
  },
  {
    "objectID": "functions.html#what-is-an-isomorphism",
    "href": "functions.html#what-is-an-isomorphism",
    "title": "3  Relations and Functions",
    "section": "7.1 What is an Isomorphism?",
    "text": "7.1 What is an Isomorphism?\nAn isomorphism is a function that has a perfect inverse—it maps one set to another in a way that preserves structure.\nGiven two functions:\n\n\\(f: A \\to B\\)\n\\(g: B \\to A\\)\n\n\\(f\\) and \\(g\\) are isomorphic if:\n\\[\ng \\circ f = id_A \\quad \\text{and} \\quad f \\circ g = id_B\n\\]\nwhere \\(id_A\\) and \\(id_B\\) are identity functions that return their input unchanged."
  },
  {
    "objectID": "functions.html#why-are-functions-non-isomorphic",
    "href": "functions.html#why-are-functions-non-isomorphic",
    "title": "3  Relations and Functions",
    "section": "7.2 Why are Functions Non-Isomorphic?",
    "text": "7.2 Why are Functions Non-Isomorphic?\nThere are two main reasons why a function might not be an isomorphism:\n\n7.2.1 1. Loss of Information: Non-Injective Functions\nA function is not injective if multiple inputs map to the same output (collapsing elements).\nExample: \\[\nf(x) = x^2\n\\]\nHere, both \\(f(2) = 4\\) and \\(f(-2) = 4\\), so the function is not invertible because we lose information about whether the input was positive or negative.\n\nOpposite Property: A function is injective (one-to-one) if no two inputs map to the same output.\nRelated concept: Monomorphism (monic functions).\n\n\n\n7.2.2 2. Incomplete Coverage: Non-Surjective Functions\nA function is not surjective if it does not cover the entire codomain.\nExample: Suppose \\(f: \\mathbb{R} \\to \\mathbb{R}\\) is defined by:\n\\[\nf(x) = e^x\n\\]\nSince the function never produces negative numbers, it is not surjective onto \\(\\mathbb{R}\\).\n\nOpposite Property: A function is surjective (onto) if it covers the entire codomain.\nRelated concept: Epimorphism (epic functions)."
  },
  {
    "objectID": "functions.html#why-is-a-bijective-function-an-isomorphism",
    "href": "functions.html#why-is-a-bijective-function-an-isomorphism",
    "title": "3  Relations and Functions",
    "section": "8.1 Why is a Bijective Function an Isomorphism?",
    "text": "8.1 Why is a Bijective Function an Isomorphism?\nA bijective function is an isomorphism because it:\n\nPreserves uniqueness (no collapsing).\nFully maps the codomain (no gaps).\nHas an inverse function that undoes its effect.\n\nExample:\nThe function \\(f(x) = x + 3\\) is bijective because:\n\nIt is injective (each \\(x\\) gives a unique output).\nIt is surjective (covers all real numbers).\nIt has an inverse \\(g(x) = x - 3\\), making it an isomorphism."
  }
]